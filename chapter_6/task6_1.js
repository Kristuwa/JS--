//----------------------------------------task-1--------------------------//

/* Вычислить сумму чисел до данного
важность: 5
Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
Например:
sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
Сделайте три варианта решения:

С использованием цикла.
Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.
С использованием формулы арифметической прогрессии.
Пример работы вашей функции:*/

function sumTo(n) {
  if (n === 1) {
    return n;
  } else {
    return (n += sumTo(n - 1));
  }
}
function sumTo1(n) {
  let total = 0;
  for (let i = 1; i <= n; i += 1) {
    total += i;
  }
  return total;
}
function sumTo2(n) {
  return ((1 + n) * n) / 2;
}

alert(`рекурсия ${sumTo(100)}`); // 5050
alert(`цикл ${sumTo1(100)}`); // 5050
alert(`формула ${sumTo2(100)}`); // 5050
/*P.S. Какой вариант решения самый быстрый? Самый медленный? Почему? Быстрый через формулу арифметической прогрессии, так как нужно выполнить 3 действия.А самый долгий способ - через рекурсию, так как запускается функция - несколько раз и загружает стек

P.P.S. Можно ли при помощи рекурсии посчитать sumTo(100000)? Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев.*/

//----------------------------------------task-2--------------------------//
/*Вычислить факториал

Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
Определение факториала можно записать как:

n! = n * (n - 1) * (n - 2) * ...*1
Примеры значений для разных n:

1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.

alert( factorial(5) ); // 120
P.S. Подсказка: n! можно записать как n * (n-1)! Например: 3! = 3*2! = 3*2*1! = 6*/
function factorial(n) {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
alert(factorial(5)); // 120

//---------------------------------------task-3-------------------------//

/*Числа Фибоначчи

Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.
Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.
P.S. Все запуски функций из примера выше должны работать быстро. Вызов fib(77) должен занимать не более доли секунды.*/

// function fib(n) {
//   return n <= 2 ? 1 : fib(n - 2) + fib(n - 1);
// }

function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757

//---------------------------------------task-4-------------------------//

/*Вывод односвязного списка
важность: 5
Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
Напишите функцию printList(list), которая выводит элементы списка по одному.

Сделайте два варианта решения: используя цикл и через рекурсию.

Как лучше: с рекурсией или без? цикл проще, не требует большей затраты ресурсов*/

function printList(list) {
  const keys = Object.keys(list);
  console.log(list);
  if (list[keys[1]]) {
    printList(list[keys[1]]);
  }
}

function printListFor(list) {
  let obj = list;

  for (let i = 1; i <= 4; i += 1) {
    console.log(obj);
    obj = obj.next;
  }
}

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};

printList(list);
printListFor(list);

//---------------------------------------task-5-------------------------//
/*Вывод односвязного списка в обратном порядке
Выведите односвязный список из предыдущего задания Вывод односвязного списка в обратном порядке.
Сделайте два решения: с использованием цикла и через рекурсию.*/

function printListReverse(list) {
  const keys = Object.keys(list);

  if (list[keys[1]]) {
    printListReverse(list[keys[1]]);
  }
  console.log(list);
}

function printListReverseFor(list) {
  let obj = list;
  let arrayOfList = [];
  for (let i = 1; i <= 4; i += 1) {
    arrayOfList.push(obj);
    obj = obj.next;
  }
  arrayOfList.reverse().map((item) => console.log(item));
}

printListReverse(list);
printListReverseFor(list);
